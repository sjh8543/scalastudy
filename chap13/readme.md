# Chap13


### 1. 중요 콜렉션 트레이트 ###
* Iterable을 상속하는 콜렉션 계층도 참고 ( 다른점을 찾아 보아요 Java와 )
* 다른점은 Map도 콜렉션의 하위 계층으로 본다는 점과 리스트도 없다는 점
* seq는 배열이나 리스트 같은 순서가 있는 일련의 값 
* IndexedSeq는 이름에서 짐작할수 있듯이 인덱스를 이용한 빠른 무작위 접근이 가능
* set 순서가 없는 집합. SortedSet은 항상 정렬되어 있는 집합을 의미
* 생각해볼점 ) LinkedList , ArrayList 가 무작위 접근에서 불편한 이유. 혹은 정렬된 List 형태의 자료에서 특정 순번 자료 추출이 필요한 경우는? 


### 2. 수정가능한 콜렉션과 수정 불가능한 콜렉션 ###
* 수정가능한( mutable ) 콜렉션 , 수정불가능한( immutable ) 콜렉션 둘 다 지원
* mutable , imutable.. 각 콜렉션의 내부 값들이 변경될수 있냐 없냐 차이 
* 스칼라는 수정 불가능한 콜렉션을 선호
* 정수 자리수 구하는 예제를 보며 Immutable Collectiond 유용하게 쓰이는 예를 직접 보자


###3. Sequence###
* 수정 불가능 시퀀스 ( Vector , Range ) , 수정 가능 시퀀스 ( ArrayBuffer ) 
* 자료구조 수업에서 들었던 C++의 LinkedList와 스칼라의 LinkedList는 다르다는데 뭘까?


###4. List###
* List는 수정 불가능 ( 앞에 2절의 정수 구하는 예제 한번 다시 보고 오세요 )
* List는 Head 와 tail로 되어 있다. List에 2라는 원소 하나만 있을 때 내부적으로 2(head)::nil(tail)로 이루어져 있음을 유의하자
* List(4,2) 는 4 :: ( 2 :: nil ) 여기에 9라는 원소가 더 들어온다면 9 :: ( 4 :: ( 2 :: nil ) ) 
* :: head와 tail를 받아 신규 리스트를 생성하는 연산자 오른쪽에서 왼쪽으로 결합하여 연산
* Iterator 말고 재귀로 멋지게 호출해서 Sum할수도 있지만 이미 라이브러리에 있다. 


###5. 수정 가능한 List 
* Elem에 head를 대입하고 next에 tail을 대입하여 수정 가능하다는 점을 제외하고는 List와 유사하게 동작
* DoubleLinkedList의 경우는 Prev 레퍼런스가 있음 


###6. 집합###
* 중복을 허용하지 않고 삽입순서를 기억하지 않는 자료구조 
* Set(2,0,1) + 1 은 연산후에도 동일하게 Set(2,0,1) 이다.
* 기본적으로 집합은 HashCode 메소드의 값에 따라 정의되는 해시집합으로 구현된다. 따라서 배열이나 리스트에서 어떤 원소를 찾는 것보다 성능이 더 빠르다. 
* 생각해볼 점) 이진검색트리 , 해시테이블의 효율성을 다시 상기
* 비트 집합은 음수가 아닌 정수의 집합을 일련의 비트로 구현 ( 왜 양의 정수 ? ) 
* i 가 집합에 있으면 i 번째 비트가 1 -> 따라서 최대원소가 크지 않은 선에서 효율적인 구현 
* union , intersect , diff는 합집합 , 교집합 , 차집합 연산을 수행하는 메소드 


###9. 합수매핑
* map 메소드는 함수를 map method caller 콜렉션의 모든 원소에 적용하고 결과 컬렉션을 반환한다 
```scala
val names = List("Peter" , "Mary" , "Paul" )
names.map(_toUpperCase) //List("PETER","MARY","PAUL")
```

