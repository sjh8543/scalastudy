# Chap13


### 1. 중요 콜렉션 트레이트 ###
* Iterable을 상속하는 콜렉션 계층도 참고 ( 다른점을 찾아 보아요 Java와 )
* 다른점은 Map도 콜렉션의 하위 계층으로 본다는 점과 리스트도 없다는 점
* seq는 배열이나 리스트 같은 순서가 있는 일련의 값 
* IndexedSeq는 이름에서 짐작할수 있듯이 인덱스를 이용한 빠른 무작위 접근이 가능
* set 순서가 없는 집합. SortedSet은 항상 정렬되어 있는 집합을 의미
* 생각해볼점 ) LinkedList , ArrayList 가 무작위 접근에서 불편한 이유. 혹은 정렬된 List 형태의 자료에서 특정 순번 자료 추출이 필요한 경우는? 


### 2. 수정가능한 콜렉션과 수정 불가능한 콜렉션 ###
* 수정가능한( mutable ) 콜렉션 , 수정불가능한( immutable ) 콜렉션 둘 다 지원
* mutable , imutable.. 각 콜렉션의 내부 값들이 변경될수 있냐 없냐 차이 
* 스칼라는 수정 불가능한 콜렉션을 선호
* 정수 자리수 구하는 예제를 보며 Immutable Collectiond 유용하게 쓰이는 예를 직접 보자


###3. Sequence###
* 수정 불가능 시퀀스 ( Vector , Range ) , 수정 가능 시퀀스 ( ArrayBuffer ) 
* 자료구조 수업에서 들었던 C++의 LinkedList와 스칼라의 LinkedList는 다르다는데 뭘까?


###4. List###
* List는 수정 불가능 ( 앞에 2절의 정수 구하는 예제 한번 다시 보고 오세요 )
* List는 Head 와 tail로 되어 있다. List에 2라는 원소 하나만 있을 때 내부적으로 2(head)::nil(tail)로 이루어져 있음을 유의하자
* List(4,2) 는 4 :: ( 2 :: nil ) 여기에 9라는 원소가 더 들어온다면 9 :: ( 4 :: ( 2 :: nil ) ) 
* :: head와 tail를 받아 신규 리스트를 생성하는 연산자 오른쪽에서 왼쪽으로 결합하여 연산
* Iterator 말고 재귀로 멋지게 호출해서 Sum할수도 있지만 이미 라이브러리에 있다. 


###5. 수정 가능한 List 
* Elem에 head를 대입하고 next에 tail을 대입하여 수정 가능하다는 점을 제외하고는 List와 유사하게 동작
* DoubleLinkedList의 경우는 Prev 레퍼런스가 있음 


###6. 집합###
* 중복을 허용하지 않고 삽입순서를 기억하지 않는 자료구조 
* Set(2,0,1) + 1 은 연산후에도 동일하게 Set(2,0,1) 이다.
* 기본적으로 집합은 HashCode 메소드의 값에 따라 정의되는 해시집합으로 구현된다. 따라서 배열이나 리스트에서 어떤 원소를 찾는 것보다 성능이 더 빠르다. 
* 생각해볼 점) 이진검색트리 , 해시테이블의 효율성을 다시 상기
* 비트 집합은 음수가 아닌 정수의 집합을 일련의 비트로 구현 ( 왜 양의 정수 ? ) 
* i 가 집합에 있으면 i 번째 비트가 1 -> 따라서 최대원소가 크지 않은 선에서 효율적인 구현 
* union , intersect , diff는 합집합 , 교집합 , 차집합 연산을 수행하는 메소드 


###9. 합수매핑
* map 메소드는 함수를 map method caller 콜렉션의 모든 원소에 적용하고 결과 컬렉션을 반환한다 
```scala
val names = List("Peter" , "Mary" , "Paul" )
names.map(_toUpperCase) //List("PETER","MARY","PAUL")
```
* 위의 map method의 루프 변환코드를 참조 ( 미래를 암시 ) 
* 함수에 하나의 값 대신 콜렉션을 줄 경우 이를 모두 병합하고자 할때 flatMap을 사용 
* collect는 모든 입력에 대해 정의되지 않을 수 있는 부분함수와도 동작 
* foreach는 method의 사이드이팩트 ( 어렵게 얘기했지만 caller collecion의 상태 변화 )만 원하고 함수 호출후 리턴값에 대해 신경쓰지 않을 경우 사용


###10. 리듀싱 , 폴딩 , 스캐닝
* map의 경우 단항 함수 , 요번 절의 메소드의 경우 Collection 내부 원소들을 이항함수로 합친다.
* reduceLeft(op) 는 콜렉션 왼쪽에 있는 원소부터 op( ex '+' , '-' ) 로 이항 연산을 해 합친다.

```scala
List(1,7,2,9).reduceLeft(_-_)
List(1,7,2,9).reduceRight(_-_)
```

* 시작원소로부터 동일한 형태로 계산을 원하는 경우 foldLeft , foldRight를 사용

```scala
List(1,7,2,9).foldLeft(0)(_-_)
List(1,7,2,9).foldRight(0)(_-_)
```

* 중요한 Tip fold는 루프에 대한 대체자로 매우 매력적 ( 9절에서 던진 떡밥 회수 ) 

###11. 지핑
* 두 컬렉션을 병합하고자 할떄 zip 메소드를 사용
* 여기에 map function 적용 가능 
* 만약 zip 하고자 하는 collection 의 길이가 맞지 않을 경우 짧은쪽을 기준으로 지핑해 컬렉션을 리턴 
* zipAll의 경우 짧은 컬렉션의 경우 디폴트 값을 지정할 수 있게 해준다. 
* zipWithIndex는 해당 collecion의 두번째 요소가 각 원소의 인덱스인 쌍의 리스트를 반환


###12 ~ 13. 이터레이터 , 스트림
* 이미 앞서 본 함수들로 인하여 더 쉽게 Collection 내부 값들을 편하게 얻을수 있음을 알기에 Iterator가 C++ , java처럼 빈번히 사용되지는 않는다.
* 다만 모든 Colletion의 생성이 비효율 적일 경우 사용 ( grouped , sliding과 같은 부분집합의 이터레이터를 주는 함수를 이용하여 ) 
```scala
( 1 to 10 ).iterator.grouped(5) 
( 1 to 10 ).iterator.sliding(5) 
```
* 앞서 Iterator는 Collection의 일부분만 생성하여 작업을 할수 있는 "레이지" 대안
* 하지만 Iterator는 깨지기 쉽다 ( 왜? ) 
* 스트림은 꼬리만 "레이지"하게 수행될 수 있는 수정 불가능 리스트이다. 말을 어렵게 꼬았지만 Immutable List다. 
* take 호출 후 force를 호출함으로 원하는 위치까지 작업한 결과를 받을수 있다. 


###14. 레이지 뷰 
* 스트림 말고 다른 Collection 에 대해서도 스트림과 같은 비슷한 효과를 View를 이용해 낼 수 있다. 
* view의 경우 스트림과 달리 어떤 값도 캐쉬 하지 않는다 ( 정확히 딱 계산만 한다! ) 
* 이를 이용하여 큰 컬렉션을 복수 연산할 경우 큰 컬렉션이 중간 계산 과정 중에 생성되지 않기 때문에 매우 유용하게 사용될 수 있다. 


###17. 병렬 컬렉션 
* 스칼라는 큰 콜렉션을 보다 빠르고 효율적으로 계산하기 위한 병렬화 할 수 있는 방법을 제시한다. 
* par 메소드는 병렬구현을 생성한다.
* par 메소드에서 리턴하는 병렬 콜렉션은 Iterable의 서브타입이 아님을 주의! 병렬콜렉션 -> 순차콜렉션으로 변환하든지 하는 작업이 필요하다. 
 


